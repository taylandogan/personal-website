__NUXT_JSONP__("/blog/2015-12-29-Postgresql-Performance-Tweak-Immutable", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){return {data:[{article:{slug:"2015-12-29-Postgresql-Performance-Tweak-Immutable",description:"In PostgreSQL, every function has one of the possible volatility classifications: volatile, static and immutable. When it is not specified, PostgreSQL assumes that it is a volatile function, which is not always the case.",layout:"post",title:"Postgresql Performance Tweak - Immutable",tags:["programming","postgresql"],createdAt:h,updatedAt:h,toc:[],body:{type:i,children:[{type:b,tag:e,props:{},children:[{type:a,value:j},{type:b,tag:d,props:{},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:d,props:{},children:[{type:a,value:l}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:n}]},{type:a,value:o}]},{type:a,value:c},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"TL;DR"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Volatile:"}]},{type:a,value:" functions with side-effects."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Immutable:"}]},{type:a,value:" pure functional functions."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Stable:"}]},{type:a,value:" smth in between. (wow, such explanation, very clear "},{type:b,tag:p,props:{},children:[{type:a,value:"applause"}]},{type:a,value:")"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Yes, IMHO stable is utterly error-prone and you need to consult to the documentation. Sorry that TL;DR was inadequate :( ..(but.. it is supposed to be inadequate by definition right?? whatever..)"}]},{type:a,value:c},{type:b,tag:"div",props:{style:"text-align:center",markdown:"1"},children:[{type:a,value:c},{type:b,tag:"article-image",props:{src:"jake_amazed.gif",alt:""},children:[{type:a,value:c}]},{type:a,value:c},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"So, I’d like to draw your attention to immutable functions before this post gets too long. When declaring a function, using the immutable keyword actually implies the following:"}]},{type:a,value:c},{type:b,tag:"ul",props:{},children:[{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"I solemnly swear that my function "},{type:b,tag:d,props:{},children:[{type:a,value:"does not modify"}]},{type:a,value:" the db."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"It does not do any database lookups."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Given the same arguments, it "},{type:b,tag:d,props:{},children:[{type:a,value:"ALWAYS"}]},{type:a,value:" returns the same output."}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"BEWARE:"}]},{type:a,value:" As stated in the PostgreSQL documentation, your function should be volatile if you use anything like "},{type:b,tag:d,props:{},children:[{type:a,value:"random()"}]},{type:a,value:f},{type:b,tag:d,props:{},children:[{type:a,value:"currval()"}]},{type:a,value:f},{type:b,tag:d,props:{},children:[{type:a,value:"timeofday()"}]},{type:a,value:f},{type:b,tag:d,props:{},children:[{type:a,value:"current_timestamp()"}]},{type:a,value:", etc. in your function."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Reader:"}]},{type:a,value:" "},{type:b,tag:p,props:{},children:[{type:a,value:"“So, like.. when shall I use immutable functions? “"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Recently, we had to implement a hash function and it was much more appropriate to do the job in PL \u002F pgSQL. So it was all sunshine and lollipops, the hash function came out well etc. But unfortunately it was a tad bit slow. To fix this issue, we just altered the volatility classification of some helper functions. For example, a function that converts characters into ascii values was perfectly suitable to use the immutable keyword!"}]}]},excerpt:{type:i,children:[{type:b,tag:e,props:{},children:[{type:a,value:j},{type:b,tag:d,props:{},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:d,props:{},children:[{type:a,value:l}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:n}]},{type:a,value:o}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002F2015-12-29-Postgresql-Performance-Tweak-Immutable",extension:".md"}}],fetch:{},mutations:void 0}}("text","element","\n","strong","p",", ","li","2015-12-29T00:00:00.000Z","root","In PostgreSQL, every function has one of the possible volatility classifications: ","volatile","static"," and ","immutable",". When it is not specified, PostgreSQL assumes that it is a volatile function, which is not always the case.","em")));